import pytest
from requests import Response
from requests_oauthlib import OAuth2Session

from pardner.services import (
    GroupMeTransferService,
    StravaTransferService,
    TumblrTransferService,
)
from pardner.verticals import (
    BlockedUserVertical,
    ConversationDirectVertical,
    PhysicalActivityVertical,
    SocialPostingVertical,
)
from pardner.verticals.base import BaseVertical

# CLASSES


class NewVertical(BaseVertical):
    vertical_name: str = 'new_vertical'


class ExtraScopeVertical(BaseVertical):
    vertical_name: str = 'extra_scope_vertical'


# FIXTURES


@pytest.fixture
def mock_nested_dict(mocker):
    def nested_dict():
        mock_dict = mocker.MagicMock(spec=dict, name='mock_nested_dict')
        mock_dict.__getitem__.side_effect = lambda _: nested_dict()
        mock_dict.get.side_effect = lambda _, default=None: nested_dict()
        mock_dict.__contains__.side_effect = lambda _: True
        return mock_dict

    return nested_dict()


@pytest.fixture
def mock_oauth2_session_request(mocker):
    return mocker.patch('requests_oauthlib.OAuth2Session.request')


@pytest.fixture
def mock_oauth2_session_response(mocker):
    return mocker.patch(
        'oauthlib.oauth2.rfc6749.clients.WebApplicationClient.parse_request_body_response'
    )


@pytest.fixture
def mock_tumblr_transfer_service(verticals=[SocialPostingVertical]):
    return TumblrTransferService(
        'fake_client_id', 'fake_client_secret', 'https://redirect_uri', None, verticals
    )


@pytest.fixture
def mock_strava_transfer_service(verticals=[PhysicalActivityVertical]):
    return StravaTransferService(
        'fake_client_id', 'fake_client_secret', 'https://redirect_uri', None, verticals
    )


@pytest.fixture
def groupme_transfer_service(
    verticals=[BlockedUserVertical, ConversationDirectVertical],
):
    groupme = GroupMeTransferService(
        client_id='fake_client_id',
        redirect_uri='https://redirect_uri',
        verticals=verticals,
    )
    groupme._oAuth2Session.token = {'access_token': 'fake_token'}
    groupme._user_id = None
    return groupme


@pytest.fixture
def mock_oauth2_bad_response(mocker):
    mock_response = mocker.create_autospec(Response)
    mock_response.ok = False
    mock_response.status_code = 400
    mock_response.reason = 'fake reason'
    mock_response.url = 'fake url'
    mock_response.raise_for_status = lambda: Response.raise_for_status(mock_response)
    return mock_response


@pytest.fixture
def mock_oauth2_session_get_bad_response(mocker, mock_oauth2_bad_response):
    oauth2_session_get = mocker.patch.object(OAuth2Session, 'get', autospec=True)
    oauth2_session_get.return_value = mock_oauth2_bad_response
    return oauth2_session_get


@pytest.fixture
def mock_oauth2_good_response(mocker, mock_nested_dict):
    mock_response = mocker.create_autospec(Response)
    mock_response.ok = True
    mock_response.status_code = 200
    mock_response.url = 'fake url'
    mock_response.json.return_value = mock_nested_dict
    return mock_response


@pytest.fixture
def mock_oauth2_session_get_good_response(mocker, mock_oauth2_good_response):
    oauth2_session_get = mocker.patch.object(OAuth2Session, 'get', autospec=True)
    oauth2_session_get.return_value = mock_oauth2_good_response
    return oauth2_session_get


# HELPERS


def mock_oauth2_session_get(mocker, response_object=None):
    oauth2_session_get = mocker.patch.object(OAuth2Session, 'get', autospec=True)
    oauth2_session_get.return_value = response_object
    return oauth2_session_get


def dump_and_filter_model_objs(model_objs):
    """
    ``pardner_object_id`` is auto-generated by pardner so we don't need to compare
    it when testing.
    """
    model_obj_dumps = [model_obj.model_dump() for model_obj in model_objs]
    for model_obj_dump in model_obj_dumps:
        del model_obj_dump['pardner_object_id']
    return model_obj_dumps
